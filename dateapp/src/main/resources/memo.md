채팅 기능을 구현할 때 알아야할 개념
1. WebSocket 개념 알기
2. 스프링에서는 STOMP를 사용하여 웹소켓을 구현할 수 있음
3. STOMP: 웹소켓 위에서 동작하는 메시징 프로토콜로, 사용자와 서버 간의 메시지 교환을 용이하게 해줌
4. RESTFul API: 채팅 요청, 수락 등의 기능을 위한 API를 구현해야됨

구현 방법
1. 프로젝트 설정: 스프링부트를 사용하여 프로젝트를 생성하고, 웹소켓과 STOMP 의존성을 추가
2. 웹소켓 설정: WebSocketMessageBrokerConfigurer를 구현하여 WebSocket 및 STOMP 엔드포인트를 설정
3. 채팅 요청 및 수락 기능 구현:
- 채팅 요청을 보내는 API 엔드포인트 생성
- 요청을 수락하는 API 엔드포인트 생성
- 채팅방 생성 로직 구현
4. 채팅 기능 구현:
- 메시지를 주고받는 웹소켓 핸들러 구현
- 클라이언트에서 메시지를 전송하고 수신하는 로직 구현
5. 프론트엔드:
- 웹소켓 클라이언트 구현(자바스크립트 사용)
- 채팅 UI 구현
6. 데이터베이스 연동:
- JPA를 사용하여 채팅 관련 데이터 저장 및 조회


설계
1. 사용자가 상대방한테 채팅요청을 보내면
2. 상대방은 요청을 수락하거나 거절 할 수 있다.
3. 수락한 경우 채팅방이 생겨서 실시간 채팅이 가능해진다.
4. 채팅 기능을 구현하기 위해 웹소켓을 설정

--- 공부 ---
pub/sub 모델
1. 발행
- 발행자는 특정 주제(Topic) 또는 큐(Queue)에 메시지를 전송. 전송하는데만 관심 있고 어떤 소비자가 받을지는 신경 X
- 발행자는 메시지를 보내는 'SEND' 명령을 사용하여 특정 목적지에 메시지를 전송
2. 구독
- 구독자는 특정 주제나 큐를 구독하여 해당 주제나 큐로 전송된 메시지 수신
- 구독자는 'SUBSCRIBE' 명령을 사용하여 특정 목적지에 구독을 요청
3. 브로커
- 브로커는 발행자가 보낸 메시지를 적절한 구독자에게 전달하는 역할 브로커가 메시지를 수신하고 이를 적절한 주제나 큐에 라우팅

--- 메모 ---
1. 그룹채팅X 일대일 채팅만 하기 때문에 엔티티간의 연관관계 안맺음
2. registry.setApplicationDestinationPrefixes("/pub") 때문에 /pub이 붙은 주소를 찾고 이 주소와 매칭되는 @MessageMapping 애노테이션이 붙은 메소드를 찾습니다.
3. 웹 소켓의 데이터 통신은 내부적으로 JSON을 사용하기 때문에 JSON 라이브러리를 추가하지 않으면 Error가 발생
4. 웹소켓 설정을 Queue방식으로 사용하기 위해 Redis를 사용
5. implementation 'org.springframework.boot:spring-boot-starter-data-redis' 의존성 추가